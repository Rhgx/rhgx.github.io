<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Slide Puzzle</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <style>
      :root {
        color-scheme: dark;
      }

      body {
        background: #0a0a0a;
        color: #e5e5e5;
      }

      .btn {
        border-radius: 0.375rem;
        border: 1px solid #3f3f46;
        background: #262626;
        padding: 0.5rem 0.75rem;
        font-size: 0.875rem;
        font-weight: 500;
        color: #f5f5f5;
        transition: background-color 0.15s ease, border-color 0.15s ease,
          color 0.15s ease, transform 0.06s ease;
      }
      .btn:hover {
        background: #3f3f46;
      }
      .btn:active {
        background: #52525b;
      }
      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .btn-accent {
        border-color: #1f3a2b;
        background: #0f1e17;
      }
      .btn-accent:hover {
        background: #1a2f24;
      }

      .btn-danger {
        border-color: #7f1d1d;
        background: #1a0b0b;
        color: #fecaca;
      }
      .btn-danger:hover {
        background: #7f1d1d;
        color: #fff5f5;
      }

      .badge {
        border-radius: 0.375rem;
        border: 1px solid #3f3f46;
        background: linear-gradient(180deg, #0f0f0f, #0b0b0b);
        padding: 0.25rem 0.5rem;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 0.875rem;
        color: #e5e5e5;
      }

      .tile {
        position: absolute;
        left: 0;
        top: 0;
        user-select: none;
        overflow: hidden;
        border-radius: 0.375rem;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.45);
        background-repeat: no-repeat;
        background-size: cover;
        background-image: url("assets/puzzle.png");
        image-rendering: auto;
        backface-visibility: hidden;
        transform: translate3d(0, 0, 0);
        outline: 1px solid rgba(255, 255, 255, 0.06);
        background-color: #262626;
        transition: box-shadow 0.15s ease;
      }
      .tile:hover {
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.55);
      }

      .tile-label {
        position: absolute;
        bottom: 0.25rem;
        right: 0.25rem;
        padding: 0 0.25rem;
        border-radius: 0.25rem;
        background: rgba(0, 0, 0, 0.6);
        font-size: 10px;
        font-weight: 700;
        color: #ffffff;
      }

      .board-frame {
        position: relative;
        overflow: hidden;
        border-radius: 0.75rem;
        border: 1px solid #27272a;
        background: radial-gradient(
            1200px 400px at -20% -20%,
            rgba(255, 255, 255, 0.04),
            transparent 50%
          ),
          linear-gradient(180deg, #0b0b0b, #0a0a0a);
      }

      .board-grid-lines::after {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        background-image: linear-gradient(
            to right,
            rgba(255, 255, 255, 0.06) 1px,
            transparent 1px
          ),
          linear-gradient(
            to bottom,
            rgba(255, 255, 255, 0.06) 1px,
            transparent 1px
          );
        background-size: calc(100% / 5) calc(100% / 5); /* Number */
        mix-blend-mode: overlay;
      }

      .overlay {
        position: absolute;
        inset: 0;
        z-index: 20;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.7);
        -webkit-backdrop-filter: blur(6px);
        backdrop-filter: blur(6px);
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      #shuffleBtn {
        visibility: hidden;
      }
    </style>
  </head>
  <body
    class="min-h-screen text-neutral-100 antialiased selection:bg-neutral-700 selection:text-white"
  >
    <div class="mx-auto flex max-w-xl flex-col gap-5 p-5">
      <header class="flex items-center justify-between gap-3">
        <h1 class="text-xl font-semibold tracking-wide text-neutral-100">
          Slide Puzzle
        </h1>
        <div class="flex items-center gap-2">
          <span id="timer" class="badge" aria-live="polite">00:00</span>
        </div>
      </header>

      <div class="flex items-center justify-between gap-3">
        <div class="flex items-center gap-2">
          <button id="resetBtn" class="btn btn-danger">Reset</button>
          <button id="shuffleBtn" class="btn btn-accent">Shuffle</button>
        </div>
        <label
          class="inline-flex cursor-pointer select-none items-center gap-2 text-sm text-neutral-300"
        >
          <input id="numbersToggle" type="checkbox" class="accent-neutral-400" />
          Show numbers
        </label>
      </div>

      <main class="board-frame">
        <div
          id="board"
          class="board-grid-lines relative aspect-square w-full outline-none"
          tabindex="0"
          aria-label="Slide puzzle board"
        >
          <div
            id="loading"
            class="absolute inset-0 z-10 flex items-center justify-center text-neutral-400"
          >
            Loadingâ€¦
          </div>

          <div id="winOverlay" class="overlay hidden">
            <div
              class="mx-6 w-full max-w-xs rounded-xl border border-neutral-700 bg-neutral-900 p-5 text-center shadow-xl"
            >
              <h2 class="mb-2 text-lg font-semibold">Completed!</h2>
              <p id="finalTime" class="mb-4 text-sm text-neutral-300"></p>
              <div class="flex justify-center gap-2">
                <button id="playAgainBtn" class="btn btn-accent">
                  Shuffle again
                </button>
                <button id="closeOverlayBtn" class="btn">Close</button>
              </div>
            </div>
          </div>
        </div>
        <p class="sr-only" role="status" aria-live="polite" id="status"></p>
      </main>

      <footer class="text-center text-xs text-neutral-500">
        <p class="text-neutral-100">Solve the Doctor</p>
       <p> Click or tap tiles next to the empty space. Use arrow keys, too.</p>
      </footer>
    </div>

    <script>
      (() => {
        "use strict";

        const N = 5; // Number
        const SIZE = N * N;
        const BLANK = SIZE - 1;
        const GAP = 6;

        const boardEl = document.getElementById("board");
        const loadingEl = document.getElementById("loading");
        const timerEl = document.getElementById("timer");
        const statusEl = document.getElementById("status");
        const shuffleBtn = document.getElementById("shuffleBtn");
        const resetBtn = document.getElementById("resetBtn");
        const numbersToggle = document.getElementById("numbersToggle");
        const winOverlay = document.getElementById("winOverlay");
        const finalTimeEl = document.getElementById("finalTime");
        const playAgainBtn = document.getElementById("playAgainBtn");
        const closeOverlayBtn = document.getElementById("closeOverlayBtn");

        const solved = Array.from({ length: SIZE }, (_, i) => i);
        let state = [...solved];
        let tileEls = new Map();
        let boardSize = 0;
        let tileSize = 0;
        let inputLocked = false;
        let isShuffling = false;
        let isAnimatingMove = false;

        let timerId = null;
        let elapsed = 0;
        let timerStarted = false;

        function formatTime(totalSeconds) {
          const h = Math.floor(totalSeconds / 3600);
          const m = Math.floor((totalSeconds % 3600) / 60);
          const s = totalSeconds % 60;
          const pad = (n) => String(n).padStart(2, "0");
          if (h > 0) return `${pad(h)}:${pad(m)}:${pad(s)}`;
          return `${pad(m)}:${pad(s)}`;
        }

        function resetTimer() {
          stopTimer();
          elapsed = 0;
          timerStarted = false;
          timerEl.textContent = "00:00";
        }

        function startTimerIfNeeded() {
          if (timerStarted) return;
          timerStarted = true;
          timerId = setInterval(() => {
            elapsed += 1;
            timerEl.textContent = formatTime(elapsed);
          }, 1000);
        }

        function stopTimer() {
          if (timerId) {
            clearInterval(timerId);
            timerId = null;
          }
        }

        function posToRC(pos) {
          return { r: Math.floor(pos / N), c: pos % N };
        }
        function rcToPos(r, c) {
          return r * N + c;
        }
        function getBlankPos() {
          return state.indexOf(BLANK);
        }
        function isSolved() {
          for (let i = 0; i < SIZE; i++) {
            if (state[i] !== solved[i]) return false;
          }
          return true;
        }
        function neighborsOfBlank() {
          const pos = getBlankPos();
          const { r, c } = posToRC(pos);
          const res = [];
          if (r > 0) res.push(rcToPos(r - 1, c));
          if (r < N - 1) res.push(rcToPos(r + 1, c));
          if (c > 0) res.push(rcToPos(r, c - 1));
          if (c < N - 1) res.push(rcToPos(r, c + 1));
          return res;
        }

        function computeBoardMetrics() {
          const width =
            boardEl.clientWidth ||
            Math.floor(boardEl.getBoundingClientRect().width);
          boardEl.style.height = `${width}px`;
          boardSize = width;
          tileSize = Math.floor((boardSize - GAP * (N - 1)) / N);
        }

        function setTileVisual(piece, el) {
          el.style.width = `${tileSize}px`;
          el.style.height = `${tileSize}px`;

          const imgSize = tileSize * N;
          const r = Math.floor(piece / N);
          const c = piece % N;
          const pxX = -(c * tileSize);
          const pxY = -(r * tileSize);
          el.style.backgroundSize = `${imgSize}px ${imgSize}px`;
          el.style.backgroundPosition = `${pxX}px ${pxY}px`;
        }

        function posToXY(pos) {
          const { r, c } = posToRC(pos);
          const x = c * (tileSize + GAP);
          const y = r * (tileSize + GAP);
          return { x, y };
        }

        function layoutAllTiles(animate = false, duration = 0.2) {
          for (const [piece, el] of tileEls) {
            setTileVisual(piece, el);
          }
          for (let pos = 0; pos < SIZE; pos++) {
            const piece = state[pos];
            if (piece === BLANK) continue;
            const el = tileEls.get(piece);
            const { x, y } = posToXY(pos);
            if (animate) {
              gsap.to(el, { x, y, duration, ease: "power2.out" });
            } else {
              gsap.set(el, { x, y });
            }
          }
        }

        function createTiles() {
          for (const [, el] of tileEls) el.remove();
          tileEls.clear();

          for (let piece = 0; piece < SIZE - 1; piece++) {
            const el = document.createElement("div");
            el.className = "tile";
            el.dataset.piece = String(piece);

            const label = document.createElement("div");
            label.className = "tile-label";
            label.textContent = String(piece + 1);
            el.appendChild(label);

            el.addEventListener("click", () => onTileClick(piece));
            el.addEventListener("pointerdown", (e) => e.preventDefault());

            tileEls.set(piece, el);
            boardEl.appendChild(el);
          }

          applyNumbersToggle();
        }

        function onTileClick(piece) {
          if (inputLocked || isShuffling || isAnimatingMove) return;

          const posTile = state.indexOf(piece);
          const posBlank = getBlankPos();
          const { r: tr, c: tc } = posToRC(posTile);
          const { r: br, c: bc } = posToRC(posBlank);
          const dist = Math.abs(tr - br) + Math.abs(tc - bc);
          if (dist !== 1) return;

          startTimerIfNeeded();
          movePiece(posTile, posBlank, piece, true);
        }

        function movePiece(fromPos, toPos, piece, announce = false) {
          isAnimatingMove = true;
          state[toPos] = piece;
          state[fromPos] = BLANK;

          const el = tileEls.get(piece);
          const { x, y } = posToXY(toPos);
          gsap.to(el, {
            x,
            y,
            duration: 0.18,
            ease: "power2.out",
            onComplete: () => {
              isAnimatingMove = false;
              if (announce) statusEl.textContent = "Moved";
              if (isSolved()) onWin();
            },
          });
        }

        function onWin() {
          stopTimer();
          finalTimeEl.textContent = `Time: ${formatTime(elapsed)}`;
          inputLocked = true;
          winOverlay.classList.remove("hidden");
          gsap
            .timeline()
            .set(winOverlay, { display: "flex" })
            .fromTo(
              winOverlay,
              { opacity: 0 },
              { opacity: 1, duration: 0.25, ease: "power2.out" }
            )
            .fromTo(
              winOverlay.querySelector("div"),
              { y: 16, opacity: 0 },
              { y: 0, opacity: 1, duration: 0.25, ease: "power2.out" },
              "<"
            );
        }

        function hideWinOverlay() {
          gsap
            .timeline({
              onComplete: () => {
                winOverlay.classList.add("hidden");
                inputLocked = false;
              },
            })
            .to(winOverlay.querySelector("div"), {
              y: 8,
              opacity: 0,
              duration: 0.2,
              ease: "power2.in",
            })
            .to(
              winOverlay,
              { opacity: 0, duration: 0.2, ease: "power2.in" },
              "<"
            )
            .set(winOverlay, { display: "none" });
        }

        function randomInt(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function shuffleWithRandomWalk(steps = 120) {
          isShuffling = true;
          inputLocked = true;
          resetTimer();

          state = [...solved];
          layoutAllTiles(false);

          let prevBlank = getBlankPos();
          for (let i = 0; i < steps; i++) {
            const neigh = neighborsOfBlank();
            const filtered = neigh.filter((p) => p !== prevBlank);
            const choices = filtered.length > 0 ? filtered : neigh;
            const pick = choices[randomInt(0, choices.length - 1)];
            prevBlank = getBlankPos();
            const piece = state[pick];
            state[getBlankPos()] = piece;
            state[pick] = BLANK;
          }

          if (isSolved()) {
            const extra = neighborsOfBlank();
            if (extra.length) {
              const pick = extra[randomInt(0, extra.length - 1)];
              const piece = state[pick];
              state[getBlankPos()] = piece;
              state[pick] = BLANK;
            }
          }

          layoutAllTiles(true, 0.08);

          setTimeout(() => {
            isShuffling = false;
            inputLocked = false;
            statusEl.textContent = "Shuffled";
          }, 120);
        }

        function restartAndShuffle() {
          // Hide win overlay immediately if visible
          if (winOverlay.style.display === "flex") {
            gsap.set(winOverlay, { opacity: 0, display: "none" });
            winOverlay.classList.add("hidden");
            inputLocked = false;
          }
          shuffleWithRandomWalk(randomInt(90, 140));
        }

        function handleKeydown(e) {
          if (inputLocked || isShuffling || isAnimatingMove) return;

          const posBlank = getBlankPos();
          const { r, c } = posToRC(posBlank);

          let fromPos = null;
          if (e.key === "ArrowUp" || e.key === "w") {
            if (r < N - 1) fromPos = rcToPos(r + 1, c);
          } else if (e.key === "ArrowDown" || e.key === "s") {
            if (r > 0) fromPos = rcToPos(r - 1, c);
          } else if (e.key === "ArrowLeft" || e.key === "a") {
            if (c < N - 1) fromPos = rcToPos(r, c + 1);
          } else if (e.key === "ArrowRight" || e.key === "d") {
            if (c > 0) fromPos = rcToPos(r, c - 1);
          } else if (e.key === "Enter") {
            e.preventDefault();
            shuffleWithRandomWalk(randomInt(90, 140));
            return;
          } else {
            return;
          }

          if (fromPos != null) {
            e.preventDefault();
            const piece = state[fromPos];
            if (piece !== BLANK) {
              startTimerIfNeeded();
              movePiece(fromPos, posBlank, piece, false);
            }
          }
        }

        function applyNumbersToggle() {
          const show = numbersToggle.checked;
          for (const [, el] of tileEls) {
            const label = el.querySelector(".tile-label");
            if (label) label.style.display = show ? "block" : "none";
          }
        }

        function onResize() {
          computeBoardMetrics();
          layoutAllTiles(false);
        }

        function preloadImage(src) {
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve();
            img.onerror = reject;
            img.src = src;
          });
        }

        async function init() {
          try {
            await preloadImage("assets/puzzle.png");
          } catch {}

          createTiles();
          computeBoardMetrics();
          layoutAllTiles(false);

          loadingEl.style.display = "none";
          boardEl.focus();

          shuffleWithRandomWalk(randomInt(90, 140));
        }

        window.addEventListener("resize", () => {
          clearTimeout(onResize._t);
          onResize._t = setTimeout(onResize, 80);
        });

        boardEl.addEventListener("keydown", handleKeydown);
        shuffleBtn.addEventListener("click", () =>
          shuffleWithRandomWalk(randomInt(90, 140))
        );
        // Reset now auto-shuffles
        resetBtn.addEventListener("click", restartAndShuffle);
        numbersToggle.addEventListener("change", applyNumbersToggle);

        playAgainBtn.addEventListener("click", () => {
          hideWinOverlay();
          shuffleWithRandomWalk(randomInt(90, 140));
        });
        closeOverlayBtn.addEventListener("click", () => hideWinOverlay());

        init();
      })();
    </script>
  </body>
</html>